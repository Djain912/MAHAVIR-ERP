/**
 * Salary Slip Model
 * Monthly salary slips with attendance-based deductions and commission
 */

import mongoose from 'mongoose';

const salarySlipSchema = new mongoose.Schema({
  // Employee reference
  employeeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Driver',
    required: true
  },
  
  // Month and Year
  month: {
    type: Number,
    required: true,
    min: 1,
    max: 12
  },
  
  year: {
    type: Number,
    required: true
  },
  
  // Basic Salary (Monthly)
  basicSalary: {
    type: Number,
    required: true,
    min: 0
  },
  
  // Attendance Details
  attendance: {
    totalDays: { type: Number, default: 0 },
    presentDays: { type: Number, default: 0 },
    absentDays: { type: Number, default: 0 },
    halfDays: { type: Number, default: 0 },
    leaveDays: { type: Number, default: 0 },
    paidLeaveDays: { type: Number, default: 0 },
    workingDays: { type: Number, default: 0 } // Present + (HalfDay * 0.5) + PaidLeave
  },
  
  // Earnings
  earnings: {
    basicAmount: { type: Number, default: 0 }, // Pro-rated based on working days
    commission: { type: Number, default: 0 },
    bonus: { type: Number, default: 0 },
    allowances: { type: Number, default: 0 },
    overtime: { type: Number, default: 0 }
  },
  
  // Deductions
  deductions: {
    absentDeduction: { type: Number, default: 0 },
    unpaidLeaveDeduction: { type: Number, default: 0 },
    advanceDeduction: { type: Number, default: 0 },
    loanDeduction: { type: Number, default: 0 },
    lateFine: { type: Number, default: 0 },
    other: { type: Number, default: 0 }
  },
  
  // Advance payment details
  advancePayments: [{
    advanceId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'SalaryAdvance'
    },
    amount: Number,
    recoveryMonth: Number,
    recoveryYear: Number
  }],
  
  // Leave details for the month
  leaveDetails: {
    sickLeave: { type: Number, default: 0 },
    casualLeave: { type: Number, default: 0 },
    paidLeave: { type: Number, default: 0 },
    unpaidLeave: { type: Number, default: 0 },
    halfDays: { type: Number, default: 0 }
  },
  
  // Totals
  grossSalary: {
    type: Number,
    required: true
  },
  
  totalDeductions: {
    type: Number,
    required: true
  },
  
  netSalary: {
    type: Number,
    required: true
  },
  
  // Payment Details
  paymentStatus: {
    type: String,
    enum: ['Pending', 'Paid', 'Partially-Paid'],
    default: 'Pending'
  },
  
  paymentDate: {
    type: Date
  },
  
  paymentMode: {
    type: String,
    enum: ['Cash', 'Bank Transfer', 'Cheque', 'UPI']
  },
  
  paymentReference: {
    type: String,
    trim: true
  },
  
  paidAmount: {
    type: Number,
    default: 0
  },
  
  // Remarks
  remarks: {
    type: String,
    trim: true
  },
  
  // Generated by
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Driver'
  },
  
  // Status
  status: {
    type: String,
    enum: ['Draft', 'Approved', 'Paid', 'Cancelled'],
    default: 'Draft'
  }
}, {
  timestamps: true
});

// Compound index for month-year-employee uniqueness
salarySlipSchema.index({ employeeId: 1, month: 1, year: 1 }, { unique: true });

// Index for status queries
salarySlipSchema.index({ status: 1, paymentStatus: 1 });

// Pre-save middleware to calculate totals
salarySlipSchema.pre('save', function(next) {
  // Calculate gross salary (sum of all earnings)
  this.grossSalary = Object.values(this.earnings).reduce((sum, val) => sum + val, 0);
  
  // Calculate total deductions
  this.totalDeductions = Object.values(this.deductions).reduce((sum, val) => sum + val, 0);
  
  // Calculate net salary
  this.netSalary = this.grossSalary - this.totalDeductions;
  
  next();
});

// Static method to generate salary slip
salarySlipSchema.statics.generateSlip = async function(employeeId, month, year, commissionAmount = 0, generatedBy) {
  const mongoose = require('mongoose');
  const Driver = mongoose.model('Driver');
  const Attendance = mongoose.model('Attendance');
  const SalaryAdvance = mongoose.model('SalaryAdvance');
  const Leave = mongoose.model('Leave');
  
  // Get employee details
  const employee = await Driver.findById(employeeId);
  if (!employee) {
    throw new Error('Employee not found');
  }
  
  // Get employee's basic salary
  const basicSalary = employee.salary || 12000;
  
  // Get attendance summary for the month
  const startDate = new Date(year, month - 1, 1);
  const endDate = new Date(year, month, 0, 23, 59, 59, 999);
  const daysInMonth = endDate.getDate();
  
  const { attendance, summary } = await Attendance.getEmployeeSummary(
    employeeId,
    startDate,
    endDate
  );
  
  // Get leave details for the month
  const leaves = await Leave.find({
    employeeId,
    status: 'Approved',
    $or: [
      { fromDate: { $gte: startDate, $lte: endDate } },
      { toDate: { $gte: startDate, $lte: endDate } },
      { fromDate: { $lte: startDate }, toDate: { $gte: endDate } }
    ]
  });
  
  const leaveDetails = {
    sickLeave: 0,
    casualLeave: 0,
    paidLeave: 0,
    unpaidLeave: 0,
    halfDays: 0
  };
  
  let unpaidLeaveDays = 0;
  leaves.forEach(leave => {
    switch(leave.leaveType) {
      case 'Sick Leave':
        leaveDetails.sickLeave += leave.numberOfDays;
        break;
      case 'Casual Leave':
        leaveDetails.casualLeave += leave.numberOfDays;
        break;
      case 'Paid Leave':
        leaveDetails.paidLeave += leave.numberOfDays;
        break;
      case 'Unpaid Leave':
        leaveDetails.unpaidLeave += leave.numberOfDays;
        unpaidLeaveDays += leave.numberOfDays;
        break;
      case 'Half Day':
        leaveDetails.halfDays += leave.numberOfDays;
        break;
    }
  });
  
  // Calculate working days
  const paidLeaveDays = leaveDetails.sickLeave + leaveDetails.casualLeave + leaveDetails.paidLeave;
  const workingDays = summary.present + (summary.halfDay * 0.5) + paidLeaveDays;
  const absentDays = summary.absent;
  
  // Calculate per day salary
  const perDaySalary = basicSalary / daysInMonth;
  
  // Calculate pro-rated basic amount
  const basicAmount = perDaySalary * workingDays;
  
  // Calculate deductions
  const absentDeduction = perDaySalary * absentDays;
  const unpaidLeaveDeduction = perDaySalary * unpaidLeaveDays;
  
  // Get pending advances for recovery
  const pendingAdvances = await SalaryAdvance.getPendingAdvances(employeeId);
  let totalAdvanceDeduction = 0;
  const advancePayments = [];
  
  for (const advance of pendingAdvances) {
    if (advance.recovery.remainingAmount > 0) {
      const deductionAmount = Math.min(
        advance.recoveryPlan.perMonthDeduction,
        advance.recovery.remainingAmount
      );
      totalAdvanceDeduction += deductionAmount;
      advancePayments.push({
        advanceId: advance._id,
        amount: deductionAmount,
        recoveryMonth: month,
        recoveryYear: year
      });
    }
  }
  
  // Create or update salary slip
  const salarySlip = await this.findOneAndUpdate(
    { employeeId, month, year },
    {
      basicSalary,
      attendance: {
        totalDays: daysInMonth,
        presentDays: summary.present,
        absentDays: summary.absent,
        halfDays: summary.halfDay,
        leaveDays: paidLeaveDays,
        paidLeaveDays: paidLeaveDays,
        workingDays
      },
      leaveDetails,
      earnings: {
        basicAmount: Math.round(basicAmount),
        commission: commissionAmount,
        bonus: 0,
        allowances: 0,
        overtime: 0
      },
      deductions: {
        absentDeduction: Math.round(absentDeduction),
        unpaidLeaveDeduction: Math.round(unpaidLeaveDeduction),
        advanceDeduction: Math.round(totalAdvanceDeduction),
        loanDeduction: 0,
        lateFine: 0,
        other: 0
      },
      advancePayments,
      generatedBy,
      status: 'Draft'
    },
    { upsert: true, new: true }
  ).populate('employeeId', 'name phone role salary');
  
  return salarySlip;
};

// Static method to get monthly salary report
salarySlipSchema.statics.getMonthlyReport = async function(month, year) {
  return await this.find({ month, year })
    .populate('employeeId', 'name phone role')
    .sort({ 'employeeId.name': 1 });
};

// Instance method to mark as paid
salarySlipSchema.methods.markAsPaid = async function(paymentMode, paymentReference, paidAmount) {
  this.paymentStatus = paidAmount >= this.netSalary ? 'Paid' : 'Partially-Paid';
  this.paymentDate = new Date();
  this.paymentMode = paymentMode;
  this.paymentReference = paymentReference;
  this.paidAmount = (this.paidAmount || 0) + paidAmount;
  this.status = 'Paid';
  
  return await this.save();
};

const SalarySlip = mongoose.model('SalarySlip', salarySlipSchema);

export default SalarySlip;
